\documentclass{article}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\begin{document}
\title{The Mathematics of the RSA Cipher}
\author{Isaac B Goss}
\maketitle

    \section{Abstract}
        Secrecy is, I believe, a natural human tendency.  One is really only able to be oneself under the guise of confidentiality, even when not explicit.  %Could just start on the next sentence.
        It has been known that for most of the time in which humans used language, the medium through which one may communicate with any other one of similar knowledge, humans have also made attempts to hide such messages.
        Beginning with the war messages of Julius Caesar, to e-commerce in the modern day, encryption has served to hide messages from prying eyes.
        In this paper, we describe the Rivest-Shamir-Adleman (RSA) cipher, its motivation, mathematical basis, and some implementation details.
    \newpage
    \section{Caesar}
        We can define encryption like this: ``to change (information) from one form to another especially to hide its meaning (Merriam-Webster online).''  
        For the purpose of this paper, ``encryption algorithm'' and ``cipher'' will be used interchangeably.  
        With this, we can begin to talk about one of the most famous ancient ciphers, the shift cipher.  
        
        \begin{figure}[h]
        	\centering
        	\includegraphics[width=0.3\textwidth]{alphawheel}
        	\caption{Image thanks to https://inventwithpython.com}
        \end{figure}
        Begin by assembling all of the letters of your alphabet (English, for our example), in order, into a circle.  Then choose a key.  
        We call this key $k$.  
        This is a natural number less than the number of characters in your alphabet.\footnote{While it is possible to choose a key greater than the number of characters in your language, it is irrelevant as it behaves in a modular manner (ie, choosing $k=30$ means the key behaves like $30\equiv4\ (mod\ 26)$ in English). This will be explained in detail shortly.}
        We then take the message and remove all non-alphabetic characters (spaces, numerals, punctuation, etc) and lowercase each character.
        Following this, each character is taken one at a time and replaced by the character $k$ entries clockwise on our circle.
        
        An example is in order.  Suppose you wanted to share relatively sensitive information with someone you trust but no one else.  
        You might use a shift cipher to do this.
        Begin by choosing a key.  I shall choose $k=13$ for no particular reason, and share it with my trusted accomplice over secure channels, or in person.
        We then write our message:
        %Center this???
        \begin{center}
        	I love MLP.
        \end{center}
        
        Clearly, a compromising statement.  Now we remove all non-alphabetic characters and lowercase:
        
        \begin{center}
        	ilovemlp
        \end{center}
        
        We then apply our key of 13, by choosing the character 13 entries clockwise on our circle.  
        We have:
        
        \begin{center}
        	VYBIRZYC
        \end{center}
        
        Notice how the letters ``o'', ``v'', and ``p'' have ``looped around'' to the beginning of the alphabet.  
        This concept is key when we begin talking about modular arithmetic soon.
        
        So, we have encrypted our first message.  But how do we now get the original message back?  
        For this, we simply perform this process in reverse, by choosing each letter k entries \textit{counter}-clockwise, and proceed to add capitalization and other characters as seems necessary from the context of the message.
        
        This is the oldest and simplest example of how one might hide a message that is sent over insecure channels, and as you might expect, it is a very, very weak encryption.
        The disadvantages are:
        \begin{enumerate}
            \item
            There are only 25 possible keys to choose, and so even by hand it takes very little time to check each one.
            \item
            If it is possible for an attacker to encrypt (called a chosen plaintext attack) or decrypt (chosen ciphertext attack) one singular letter with this key, the key yields itself immediately.
            \item
            This cipher is very vulnerable to a frequency analysis.  In any language, it is known that certain characters and combinations of characters are used significantly more frequently than others.  For instance, ``e'' is the most commonly used letter in the English language, with an almost 13\% usage rate.  In any non-trivial amount of ciphertext you are reasonably assured that the most or second most common character is decrypted to ``e''.
            \item
            Once one knows the encryption key, it is exactly the same information as the decryption key, meaning that it is impossible to have secure messages without first sharing the key in a secure setting, and then trusting your conversation partner.  
        \end{enumerate}
        
        We will very soon look at the state-of-the-art (in 1977) technology with none of these weaknesses, and--most importantly--was the first method known to solve the final one.  
        But first, a word about numbers.
        
    \section{Number Theory}
        Many of these ideas will be understood by the reader in some intuitive way already, and while definitions are fun, it will be more fun to explain how RSA works.
        Therefore, I will attempt to codify the important ideas simply and succinctly.  
        These are the rules of number theory, the study of the integers.  We shall use the convention $\mathbf{Z}$ to denote the set of all integers $\{...,-2,-1,0,1,2,...\}$.
        
        \subsection{Basic Definitions}
        %\begin{itemize}
            \textbf{Divisibility}\\
            \underline{Definition} For $p, q, k \in\mathbf{Z}$, we say that p \textbf{divides} q, $p|q$, if and only if $q=pk$.
            
            \textbf{\textit{Examples}}
            \hspace*{\fill}    
                 {$3|6$ as $6=3\times2$} \hfill {$3\not|10$ as $10=3\times3\frac{1}{3},(3\frac{1}{3}\not\in\mathbf{Z})$}
            \hspace*{\fill}
            
            \noindent\textbf{Primes}\\
            \underline{Definition} A number $p>1$ that is divisible by only 1 and itself is called a \textbf{prime number}.  They are $\{2,3,5,7,11,...\}$.  Any integer $n>1$ that is not prime is called a composite.  There are an infinite number of these primes.  
            Furthermore, every number has a unique \textbf{prime factorization}, meaning that it can always be written as the product of the same primes.
            
            \textbf{\textit{Examples}}
            \hspace*{\fill}
	            {$24=2^{3}\times3$} \hfill {$77=7\times11 $}
            \hspace*{\fill}
            
            \noindent\textbf{Greatest Common Divisor}\\
            \underline{Definition} The \textbf{greatest common divisor} of $a$ and $b$ is the largest positive integer dividing both $a$ and $b$ and is denoted by $gcd(a,b)$.
            
            \textbf{\textit{Examples}}
            \hspace*{\fill}
	            {$gcd(34,54)=2$} \hfill {$gcd(77,24)=1$}
            \hspace*{\fill}
            
            \noindent\underline{Definition} We say that $a$ and $b$ are \textbf{relatively prime} if and only if $gcd(a,b)=1$.
            
            \textbf{\textit{Examples}} As we can see above, 77 and 24 are relatively prime, while 34 and 54 are not.
        %\end{itemize}
        \subsection{Conguences}
	        The key concept of the RSA cipher is truly modular arithmetic.  
	        Before even defining how to use it, I think it would be helpful to point out that you use modular arithmetic every day, every time you look at a clock.
	        Hours are counted \textit{mod 12} (or \textit{mod 24}), minutes are counted \textit{mod 60}, etc.  
	        It is why we say ``one o'clock'' as apposed to ``thirteen o'clock.''
	        The defining characteristic of a modular arithmetic is ``looping around'' a modulus, so that values that seem inequivalent in normal arithmetic can represent the same value.
	        
	        \noindent\underline{Definition} Let $a,b,k,n\in\mathbf{Z}$.  
	        We can say that $a\equiv b\ (mod\ n)$ --- which is read ``$a$ is congruent to $b$, mod $n$'' --- if and only if, $b=a+nk$.  
	        %Or, equivalently, if $\displaystyle\frac{a-b}{n}=k\in\mathbf{Z}$.
	        
	        %A common computer science definition of the modulo function (\%) is as the remainder of division. $a\equiv b\ (mod\ n)$ is a similar statement to $a\%n=b$.
	        \textbf{\textit{Examples}}
	        \hspace*{\fill}
		        {$13\equiv 1\ (mod\ 12)$} \hfill {$13\times4\equiv 52\equiv 0\ (mod\ 2)$}
	        \hspace*{\fill}
	        
	        The second example points out what makes this modular \textit{arithmetic}: operations.  Addition, Subtraction, Multiplication, and Exponentiation (with natural numbers) have all of the same rules as they do in standard arithmetic.  
	        Division, however is missing.  If you were given $5x\equiv 1\ (mod\ 12)$, you would have to fight the urge to conclude that $x=\frac{1}{5}$.  
	        The problem with this is that modular arithmetic is solely defined under the integers.  
	        So, how can we solve this?  We introduce the \textbf{multiplicative inverse} to solve problems like this.\\
	        \underline{Definition} For $a, a^{-1}, n, k \in\mathbf{Z}$, and for $gcd(a,n)=1$, $a^{-1}$ is the multiplicative inverse of $a$, ie, $aa^{-1}\equiv1$, $(mod\ n)$, if and only if, $1=aa^{-1}+nk$.
	        
            For these purposes, it may be useful to think of fractions in standard arithmetic as a multiplicative inverse, rather than a discrete value.  
	        $\frac{1}{5}$, for instance, is really handy to think of as a value which yields 1 when multiplied by 5.  
	        
	        So it goes in modular arithmetic.  
	        
	        Thus, we must determine a number by which one multiplies 5 and is given 1 $(mod\ 12)$.
	        The simplest way is to try multiples of 5.
	        $$5\times 2\equiv 10\not \equiv 1\ (mod\ 12)$$
	        $$5\times 3\equiv 15\equiv 3\ (mod\ 12)$$
	        $$5\times 4\equiv 20\equiv 8\ (mod\ 12)$$
	        $$5\times 5\equiv 25\equiv 1\ (mod\ 12)$$
	        Therefore, we can say that 5 is its own multiplicative inverse, mod 12.  
	        It is important to notice that 5 and 12 are relatively prime.  
	        if we were looking for $4x\equiv 3\ (mod\ 12)$, there would be no solution.
	        $$4\times2 \equiv 8 \not\equiv 3\ (mod\ 12)$$
	        $$4\times3 \equiv12 \equiv0 \not\equiv 3\ (mod\ 12)$$
	        $$4\times4 \equiv 16 \equiv4 \not\equiv 3\ (mod\ 12)$$
	        $$...$$
	        This happens because $gcd(4,12)=4$ ie, they are not relatively prime.
            
        \subsection{Modular Exponents}
            And then there was the exponent.  While, as stated above, exponentiation with natural numbers follows predictable rules, finding a root is quite a bit different.  
            \textbf{\textit{Example}} Suppose we wanted to solve $a^{2}\equiv 4\ (mod\ 21)$  for $a$.  
            You might, again, feel the urge to find the square root of 5 to answer the question, but this is not an integer, so using our standard rules of inverse powers cannot be made general.  
            What we need is an integer that solves which can be squared and when reduced $(mod\ 21)$ leaves us with 4.  
            The reader might notice that $5^2\equiv 25 \equiv 4\ (mod\ 21)$.  This is the solution to our example, but how do we make working with modular exponents general?
            
            \subsubsection{Euler's Theorem}
                First and foremost, we have to talk about Euler's $\phi$-function.
                
                \noindent\underline{Definition} Let $n\in\mathbf{N}$ be a positive integer. $\phi(n)=|\{k\in\mathbf{N}:k<n$ and $gcd(k,n)=1\}|$, ie, represents the positive integers less than n with which n is relatively prime.
                
                \textbf{\textit{Examples}}
                \hspace*{\fill}
                    {$ \phi(7)=|\{1,2,3,4,5,6\}|=6$} \hfill {$ \phi(10)=|\{1,3,7,9\}|=4 $} \hfill {$ \phi(5)=|\{1,2,3,4\}|=4 $}
                \hspace*{\fill}
                
                Notice that, basically by definition, for any prime $p$, $\phi(p)=p-1$.
	        
	\section{The Rivest-Shamir-Adleman Encryption Algorithm}
        So now we have finally come to the heart of the matter.  How do we secure messages over the open internet?  The literature often begins by establishing characters Alice, Bob, and Eve, and of the sake of tradition, I will join them.
     
        Suppose Alice wants to send a message to Bob over the open internet, but doesn't want Eve, who can intercept their traffic, to know what it said.  Now, Alice and Bob have never met, so they can't share the key to a shift cipher, for example (or, of course, one to a more competent cipher), because then Eve could decrypt their messages anyway.
     
        It's clear we need a new approach to solve problems like this.  The key breakthrough here is the use of an \textbf{asymmetric key}.  
        What this means, is that we have a different piece of information to \textit{encrypt} the message than is needed to \textit{decrypt} the message.  
        Or, more importantly, that finding the encryption (public) key given the decryption (private) key is trivial, while doing the inverse is computationally infeasible.  
        And then, we give away the encryption key to anyone who want it.
     
        Imagine the public key as a pad lock, and the private key as the key that opens that pad lock.  You can ask for another's padlock, even if you have never met, and then you will be able to send message locked, in a box perhaps, with this padlock.  It's no worry if the box is intercepted, and the adversary has access to an identical padlock, because short of brute force, there is no way to use the padlock to open up the box.
     
        Here's how it works.
        
        Bob needs to do some set-up before Alice can send him a message.  First, he chooses two large prime numbers, p and q, and then computes their product, n.  He also chooses a smaller integer e.  
        He keeps p and q secret, but sends n and e to Alice, who then encodes her message as a 
        number\footnote{Typically as ASCII, which was the standard way to represent all text on a computer in 1977.  We now use a superset of ASCII known as Unicode.} 
        m, breaks it into pieces less than n, and calculates the ciphertext c with $c\equiv m^{e}\ (mod\ n)$.  
        She then sends this ciphertext back to Bob, who was able to quickly calculate the decryption key based on his information.  
        The key used to decrypt the cipher text is the multiplicative inverse of the number used to encrypt the message.  We call this number d.  We want a value that satisfies the following.
        $$c^{d}\equiv (m^{e})^{d}\equiv m^{ed} \equiv m^1 \equiv m\ (mod\ n)$$
        
        So, how do we find d?  For this, we need 
	        
        
\end{document}












